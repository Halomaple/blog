---
layout: post
title: "7.4 私有变量"
date: 2017-06-04 18:00:00  +0800
category: [Learning, JavaScript]
tag: [JS, Private Variable]
---

严格来讲，JavaScript没有**私有成员**的概念；所有对象属性都是公有的。不过，倒是有一个私有变量的概念。任何在函数中定义的变量，都可以认为是私有变量，因为不能在函数的外部访问这些变量。

私有变量包括包含的参数、局部变量和在函数内部定义的其他函数。

```
function add(num1, num2){
	var sum = num1 + num2;
	return sum;
}
//在这个函数内部有三个内部变量：num1，num2和sum。在函数内部可以访问这三个变量，但在函数外部不能访问它们。利用这一点，可以创建用于访问私有变量的公有方法。
```

我们把有权访问私有变量和私有函数的公有方法称为**特权方法（privileged method）**。

有两种在对象上创建特权的方法：第一种是在构造函数中定义特权方法

```
function MyObject(){
	//私有变量和私有函数
	var privatedVariable = 10;

	function privatedFunction(){
		return false;
	}

	//特权方法
	this.publicMethod = function(){
		privatedVariable++;
		return privatedFunction();
	};
}

//这个模式在构造函数内部定义了所有私有变量和函数。然后有继续创建了能够访问这些私有成员的特权方法。
//能够在构造函数中定义特权方法，是因为特权方法作为闭包有权限访问在构造函数中定义的所有变量和函数。
//除了使用publiceMethod()这一个途径外，没有任何办法可以直接访问privateVariable和privateFunction()。
```

利用私有和特权成员，可以隐藏那些不应该被直接修改的数据。

```
function Person(name){
	this.getName = function(){
		return name;
	};

	this.setName = function(value){
		name = value;
	};
}

var person = new Person('Nicholas');
log(person.getName());	//'Nicholas'

person.setName('Greg');
log(person.getName());	//'Greg'
//私有变量name在Person的每一个实例中都不同，因为每次调用构造函数都会重新创建这两个方法。
```

在构造函数中定义特权方法也有一个缺点，那就是必须使用构造函数模式来达到这个目的。第六章讨论过，构造函数模式的缺点是针对每个实例都会创建同样一组新方法，而第二种方法就是使用静态私有变量来实现特权方法就可以避免这个问题。

## 1. 静态私有变量

通过在私有作用域中定义私有变量或函数，同样也可以创建特权方法。

```
(function(){
	//私有变量和私有函数
	var privatedVariable = 10;

	function privatedFunction(){
		return false;
	}

	//构造函数
	MyObject = function(){

	};

	//公有/特权方法
	MyObject.prototype.publicMethod = function(){
		privatedVariable++;
		return privatedFunction();
	};
})();
```

这个模式创建了一个私有作用域，并在其中封装了一个函数及相应的方法。在私有作用域中，首先定义了私有变量和函数，然后又定义构造函数及其公有方法。公有方法是在原型上定义的，这一点体现了典型的原型模式。需要注意的是，这个模式在定义构造函数时并没有使用函数声明，而是使用了函数表达式。也没有用var，所以会创建一个全局变量（严格模式下会导致错误）。

这个模式与构造函数中定义特权方法的注意区别，就在于**私有变量和函数是由实例共享**的。由于特权方法是在原型上定义的，因此所有实例都使用同一个函数。而这个特权方法，作为一个闭包，总是保存着对包含作用域的引用。

```
(function(){
	var name = '';

	Person = function(value){
		name = value;
	};

	Person.prototype.getName = function(){
		return name;
	};

	Person.prototype.setName = function(value){
		name = value;
	};
})();

var person1 = new Person('Nicholas');
log(person1.getName());	//'Nicholas'

person1.setName('Greg');
log(person1.getName());	//'Greg'

var person2 = new Person('Michael');
log(person1.getName());	//共享name现在变成了'Michael'
log(person2.getName());	//'Michael'
```

这个例子中Person与getName()和setName()方法一样，都用权访问私有变量name。在这个模式下，变量name就变成了一个静态的、由所有实例共享的属性。也就是说，在一个实例上调用setName()会影响所有实例。而调用setName()或新建一个Person实例都会赋予name属性一个新值。结果就是所有实例都会返回相同的值。

以这种方式创建静态私有变量会因为使用原型而增加代码复用，但是每个实例都没有自己的私有变量。

多查找作用域中的一个层次，就会在一定程度上影响查找速度。而这正是使用闭包和私有变量的一个显明的不足之处。