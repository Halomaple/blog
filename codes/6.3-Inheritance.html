---
layout: page
type: page
title: 6.3 继承
date: 2017-04-22 18:00:00 +0800
---
<script type="text/javascript" src="content.js"></script>
<div id="code-article-page">

实现继承一般有两种方法：接口继承和实现继承。接口继承只继承方法签名，而实现继承则继承实际的方法。ES里面没有重载，函数没有签名，所以只支持实现继承。
<h4>6.3.1 原型链</h4>
概念：每个构造函数都有一个原型对象，这个对象包含一个指向构造函数的指针，而实例都包含一个指向原型对象内部的指针。假如让原型对象等于另一个类型的实例，此时原型对象将包含指向另一个原型的指针，相应地，另一个原型中也包含着一个指向另一个构造函数的指针。假如另一个原型又是另一个类型的实例，那么
<pre>
//1. 实现原型的一种基本模式：
function SuperType(){
	this.property = true;
}
SuperType.prototype.getSuperValue = function(){
	return this.property;
};
function SubType(){
	this.subproperty = false;
}

//继承了SuperType
SubType.prototype = new SuperType();
SubType.prototype.getSubValue = function(){
	return this.subproperty;
};
var instance = new SubType();

log(instance.getSuperValue());		//true, 搜索实例》搜索SubType.prototype》搜索SuperType.prototype
log(SubType.prototype.property);	//true
log(instance.constructor);		//SuperType

log(SubType.prototype.constructor);		//SubType的原型指向SuperType的原型，而这个原型对象的constructor属性指向SuperType
log(instance.toString());	//toString()方法来自由实例SuperType继承的Object.prototype.toString()。所有函数的默认原型都是Object的实例。

newline();
//用instanceof操作符来确定实例之间的关系。只要是原型链中出现过的构造函数，结果就会返回true。
log(instance instanceof Object);	//true
log(instance instanceof SuperType);	//true
log(instance instanceof SubType);	//true

newline();
//用isPrototypeOf()方法来检测原型链中出现过的原型。
log(Object.prototype.isPrototypeOf(instance));	//true
log(SuperType.prototype.isPrototypeOf(instance)); //true
log(SubType.prototype.isPrototypeOf(instance));	//true
</pre>

<pre>
//2. 子类型有时候需要覆盖超类型中的方法，或者需要添加超类型中不存在的某个方法。但不管怎样，给原型添加方法的代码一定要放在替换原型之后。（这样才会生效）。同时也不能使用对象字面量创建原型方法，因为这样做会重写原型链。
function SuperType(){
	this.property = true;
}
SuperType.prototype.getSuperValue = function(){
	return this.property;
};

function SubType(){
	this.subproperty = false;
}
//继承了SuperType
SubType.prototype = new SuperType();

//使用字面量添加新方法，会使上一行代码无效
SuperType.prototype = {
	getSubValue: function(){
		return this.subproperty;
	},
	someOtherMethod: function(){
		return false;
	}
};

var instance = new SubType();
log(instance.getSuperType);		//undefined
</pre>

<pre>
//原型链的问题
//前面介绍过包含引用类型值的原型属性会被所有的实例共享；而这正是为什么要在构造函数中，而不是在原型对象中定义属性的原因。
//通过原型来继承实现时，原型实际上会变成另一个类型的实例。于是，原先的实例属性也就变成了现在的原型属性了。
function SuperType(){
	this.colors = ['red', 'blue', 'green'];
}
function SubType(){
}

//继承了SuperType
SubType.prototype = new SuperType();

var instance1 = new SubType();
instance1.colors.push('black');	//来自prototype的colors
log(instance1.colors);	//'red', 'blue', 'green', 'black'

var instance2 = new SubType();
log(instance2.colors);	//'red', 'blue', 'green', 'black'

//SuperType构造函数定义了一个colors属性，该属性包含一个数组（引用类型值）。SuperType的每一个实例都会有各自包含数组的colors属性。当SubType通过原型链继承了SuperType之后，SubType.prototype就变成了SuperType的一个实例，因此拥有了一个colors属性--结果SubType所有的实例都会共享这一个colors属性（这个属性是在原型对象上的。搜索过程：实例本省=>原型对象）。所以对instance1.colors的修改会反映到instance2.colors，因为他们指向的是同一个地址。

//原型链的第二个问题是：不能在不影响所有对象实例的情况下，给超类型的构造函数传递参数。
</pre>

<h4>6.3.2 借用构造函数</h4>
在解决原型中包含引用类型值所带来的问题的过程中，开发人员开始使用一种叫做“借用构造函数”（constructor stealing）的技术（有时叫伪造对象或经典继承）。这种技术是在子类型构造函数的内部调用超类型构造函数。构造函数是在特定环境中执行代码的对象，因此通过使用apply()或者call()方法也可以在（将来）新创建的对象上执行构造函数。
<pre>
function SuperType(){
	this.colors = ['red','blue','green'];
}
function SubType(){
	//继承了SuperType
	SuperType.call(this);
}

var instance1 = new SubType();
instance1.colors.push('black');
log(!instance1.hasOwnProperty('colors') && ('colors' in instance1));	//false, 检测colors是否在prototype上
log(instance1.colors);	//'red', 'blue', 'green', 'black', 操作instance1自身的属性colors

var instance2 = new SubType();
log(instance2.colors);	//'red', 'blue', 'green'
</pre>
<pre>
//构造函数的一个优势是可以在子类型构造函数中向超类型构造函数传递参数。
function SuperType(name){
	this.name = name;
}
function SubType(){
	//继承了SuperType，同时还传递了参数
	SuperType.call(this, 'Nicholas');
	//实例属性
	this.age = 20;
}

var instance1 = new SubType();
log(instance1.name);
log(instance1.age);
//在SubType构造函数内部调用SuperType构造函数时，实际上是为SubType的实例设置了name属性。为了确保SuperType构造函数不会重写子类型的属性，可以在调用超类型构造函数之后，再添加应该在子类型中定义的属性。

//借用构造函数的问题：方法都在构造函数中定义，函数复用就无从谈起了。而且，在超类型的原型中定义的方法，对于子类型而言也是不可见的。结果所有类型都只能使用构造函数模式。所以此模式也是比较少单独使用。
</pre>
</div>